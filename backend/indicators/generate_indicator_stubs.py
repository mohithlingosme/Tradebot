"""
Utility script that materializes placeholder modules for every indicator listed
in `backend/indicators/Indicator.txt`.

The project tracks 100+ indicators and keeping the module skeletons in sync
manually is error prone. This helper parses the canonical text file, derives
snake_case filenames plus PascalCase class names, and writes lightweight stub
implementations that developers can later flesh out.

Usage (from repo root):

    python -m backend.indicators.generate_indicator_stubs

Options:
- `--indicator-file`: path to the plain-text list (defaults to Indicator.txt).
- `--dest-dir`: output folder for modules (defaults to backend/indicators).
- `--overwrite`: allow replacing existing modules (defaults to skip).
- `--dry-run`: preview actions without writing files.
"""

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Sequence, Set, Tuple


ROOT_DIR = Path(__file__).resolve().parent
DEFAULT_INDICATOR_FILE = ROOT_DIR / "Indicator.txt"
DEFAULT_DEST_DIR = ROOT_DIR


@dataclass(frozen=True)
class StubPlan:
    indicator: str
    module_name: str
    class_name: str
    file_path: Path
    will_overwrite: bool = False


STUB_TEMPLATE = '''"""
{title} Indicator Placeholder

This module was auto-generated by `generate_indicator_stubs.py`. Replace the
placeholder methods with the real calculation logic and tests.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Sequence


@dataclass
class {class_name}:
    """Placeholder implementation for the {title} indicator."""

    lookback: int = 14

    def calculate(self, series: Sequence[float]) -> Optional[float]:
        """Return a single {title} value once implemented."""
        raise NotImplementedError("Implement the {title} calculation.")

    def calculate_series(self, series: Sequence[float]) -> List[Optional[float]]:
        """Return rolling {title} values once implemented."""
        raise NotImplementedError("Implement the rolling {title} calculation.")
'''


def parse_indicator_names(indicator_file: Path) -> List[str]:
    if not indicator_file.exists():
        raise FileNotFoundError(f"Indicator list not found: {indicator_file}")

    names: List[str] = []
    for raw_line in indicator_file.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line:
            continue
        normalized_header = line.lower().replace("â€™", "'")
        if normalized_header.startswith("indicator"):
            # Skip headers such as "Indicator's".
            continue
        # Insert a space when camelCase sneaks into the text file.
        spaced = re.sub(r"(?<=[a-z])(?=[A-Z])", " ", line)
        names.append(spaced)
    return names


def slugify(name: str) -> str:
    slug = re.sub(r"[^0-9a-zA-Z]+", "_", name.strip().lower())
    slug = re.sub(r"_+", "_", slug).strip("_")
    return slug


def class_name(name: str) -> str:
    parts = re.split(r"[^0-9a-zA-Z]+", name.strip())
    cleaned_parts = [part for part in parts if part]
    if not cleaned_parts:
        return "IndicatorPlaceholder"
    class_name_str = "".join(part.capitalize() for part in cleaned_parts)
    if not class_name_str or class_name_str[0].isdigit():
        class_name_str = f"Indicator{class_name_str}"
    return class_name_str


def build_plans(
    names: Sequence[str],
    dest_dir: Path,
    overwrite_existing: bool,
) -> Tuple[List[StubPlan], List[str], List[str]]:
    """
    Returns (plans, skipped_existing, skipped_duplicate).
    """
    reserved = {"__init__", "generate_indicator_stubs"}
    existing_modules = {path.stem for path in dest_dir.glob("*.py")}
    existing_modules |= reserved

    plans: List[StubPlan] = []
    skipped_existing: List[str] = []
    skipped_duplicate: List[str] = []
    seen_slugs: Set[str] = set()

    for indicator in names:
        slug = slugify(indicator)
        if not slug:
            continue
        if slug in seen_slugs:
            skipped_duplicate.append(indicator)
            continue
        seen_slugs.add(slug)

        module_path = dest_dir / f"{slug}.py"
        file_exists = module_path.exists()
        if slug in existing_modules and file_exists and not overwrite_existing:
            skipped_existing.append(indicator)
            continue

        plans.append(
            StubPlan(
                indicator=indicator,
                module_name=slug,
                class_name=class_name(indicator),
                file_path=module_path,
                will_overwrite=file_exists,
            )
        )

    return plans, skipped_existing, skipped_duplicate


def render_stub(plan: StubPlan) -> str:
    return STUB_TEMPLATE.format(title=plan.indicator, class_name=plan.class_name)


def write_stubs(plans: Sequence[StubPlan], *, dry_run: bool) -> List[Path]:
    written: List[Path] = []
    for plan in plans:
        if dry_run:
            print(f"[dry-run] Would write {plan.file_path.name} for '{plan.indicator}'")
            continue
        plan.file_path.write_text(render_stub(plan), encoding="utf-8")
        written.append(plan.file_path)
        action = "Updated" if plan.will_overwrite else "Created"
        print(f"{action} {plan.file_path.relative_to(ROOT_DIR)}")
    return written


def build_cli_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Generate placeholder indicator modules based on Indicator.txt."
    )
    parser.add_argument(
        "--indicator-file",
        type=Path,
        default=DEFAULT_INDICATOR_FILE,
        help="Path to the text file containing the indicator names.",
    )
    parser.add_argument(
        "--dest-dir",
        type=Path,
        default=DEFAULT_DEST_DIR,
        help="Directory where stub modules should be written.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing modules if they already exist.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview the files that would be created without writing them.",
    )
    return parser


def main(argv: Optional[Sequence[str]] = None) -> None:
    parser = build_cli_parser()
    args = parser.parse_args(argv)

    indicator_file = args.indicator_file.resolve()
    dest_dir = args.dest_dir.resolve()
    dest_dir.mkdir(parents=True, exist_ok=True)

    names = parse_indicator_names(indicator_file)
    plans, skipped_existing, skipped_duplicate = build_plans(
        names, dest_dir, overwrite_existing=args.overwrite
    )

    print(f"Discovered {len(names)} indicator names in {indicator_file.name}.")
    if skipped_duplicate:
        print(f"Skipped {len(skipped_duplicate)} duplicates: {skipped_duplicate}")
    if skipped_existing and not args.overwrite:
        print(
            f"Skipped {len(skipped_existing)} already-implemented indicators: {skipped_existing}"
        )
    if not plans:
        print("No new stubs to generate.")
        return

    written = write_stubs(plans, dry_run=args.dry_run)
    if not args.dry_run:
        print(f"Generated {len(written)} stub modules in {dest_dir}.")
    else:
        print(f"Dry run complete for {len(plans)} planned modules.")


if __name__ == "__main__":
    main()
