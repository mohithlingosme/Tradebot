"""
AI endpoints for Finbot
"""

import logging
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

from ..config import settings
from ..core import PromptRequest, PromptResponse, ai_pipeline
from .auth import get_current_active_user

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/ai", tags=["ai"])

DISCLAIMER_TEXT = (
    "This output is generated by an AI model for educational and informational purposes only. "
    "It is NOT investment advice, portfolio management, or a recommendation to trade in any specific "
    "security, derivative, or instrument. You are solely responsible for your trading decisions and "
    "should consult a SEBI-registered investment adviser or other qualified financial professional before acting."
)


def _mode_flag() -> str:
    """Normalize configured mode for downstream consumers."""
    return settings.finbot_mode.upper()


def _disclaimer_payload(extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Common disclaimer/regulatory guardrails for all AI outputs.

    NOTE:
    This API must never be presented as licensed investment advice.
    See SEBI (Investment Advisers) Regulations, 2013 and related circulars.
    # TODO: Have a qualified lawyer/compliance officer review this wording.
    """
    payload: Dict[str, Any] = {
        "disclaimer": DISCLAIMER_TEXT,
        "mode": _mode_flag(),
        "regulatory_flags": {
            "is_investment_advice": False,
            "requires_sebi_registration": True,
        },
        "app_use_case": getattr(settings, "app_use_case", "PERSONAL_EXPERIMENTAL"),
    }
    if extra:
        payload.update(extra)
    return payload


def _with_disclaimer(data: Dict[str, Any]) -> Dict[str, Any]:
    """Attach disclaimer metadata to the provided payload."""
    return {**data, **_disclaimer_payload()}


def _error_response(message: str, status_code: int = 500) -> JSONResponse:
    """Return a JSON error that still carries the disclaimer block."""
    return JSONResponse(
        status_code=status_code,
        content={
            "error": message,
            **_disclaimer_payload({"status": "error"}),
        },
    )


class MarketAnalysisRequest(BaseModel):
    """Market analysis request."""
    symbol: str
    market_data: Dict


class PortfolioAdviceRequest(BaseModel):
    """Portfolio advice request."""
    portfolio_data: Dict


class ResearchAssistantRequest(BaseModel):
    """Request for research brief."""
    topic: str
    focus_areas: Optional[List[str]] = None


class TradingAssistantRequest(BaseModel):
    """Trading assistant request."""
    symbol: str
    risk_profile: str = Field(default="moderate")
    account_size: float = Field(default=10000, gt=0)


class Holding(BaseModel):
    symbol: str
    weight: float = 0.1
    expected_return: float = 0.08
    volatility: float = 0.2


class PortfolioOptimizerRequest(BaseModel):
    """Advanced portfolio optimizer request."""
    holdings: List[Holding]
    risk_profile: str = "moderate"


class DecisionAssistantRequest(BaseModel):
    """Decision-making AI request."""
    company: str
    question: str


class AdviceRequest(BaseModel):
    """General-purpose advisory-style prompt (must remain educational-only)."""
    prompt: str
    context: Optional[Dict[str, Any]] = None


class RecommendationRequest(BaseModel):
    """Lightweight request for structured recommendations (educational-only)."""
    symbol: str
    risk_profile: str = Field(default="moderate")
    notes: Optional[str] = None


@router.post("/analyze-market", response_model=Dict)
async def analyze_market(
    request: MarketAnalysisRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """
    Analyze market data and provide an advisory-only trading signal.

    Args:
        request: Market analysis request
        current_user: Authenticated user

    Returns:
        Market analysis result
    """
    try:
        payload = ai_pipeline.analyze_market_signal(
            request.symbol,
            request.market_data
        )
        return _with_disclaimer({
            "symbol": request.symbol,
            "timestamp": __import__("datetime").datetime.now().isoformat(),
            **payload,
        })
    except Exception as e:
        logger.error(f"Error analyzing market: {e}")
        return _error_response("Market analysis failed")


@router.post("/portfolio-advice", response_model=Dict)
async def get_portfolio_advice(
    request: PortfolioAdviceRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """
    Get portfolio optimization advice.

    Args:
        request: Portfolio advice request
        current_user: Authenticated user

    Returns:
        Portfolio advice
    """
    try:
        payload = ai_pipeline.get_portfolio_advice(request.portfolio_data)
        return _with_disclaimer({
            "timestamp": __import__("datetime").datetime.now().isoformat(),
            **payload,
        })
    except Exception as e:
        logger.error(f"Error getting portfolio advice: {e}")
        return _error_response("Portfolio analysis failed")


@router.post("/research-assistant", response_model=Dict)
async def research_assistant(
    request: ResearchAssistantRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """Generate AI research brief."""
    try:
        payload = ai_pipeline.generate_research_brief(request.topic, request.focus_areas)
        payload["topic"] = request.topic
        return _with_disclaimer(payload)
    except Exception as exc:
        logger.error("Research assistant error: %s", exc)
        return _error_response("Research assistant failed")


@router.post("/trading-assistant", response_model=Dict)
async def trading_assistant(
    request: TradingAssistantRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """Provide AI-based trading plan (advisory only; never auto-executes)."""
    try:
        payload = ai_pipeline.generate_trading_plan(
            request.symbol, request.risk_profile, request.account_size
        )
        payload["symbol"] = request.symbol
        payload.setdefault("plan", {})
        return _with_disclaimer(payload)
    except Exception as exc:
        logger.error("Trading assistant error: %s", exc)
        return _error_response("Trading assistant failed")


@router.post("/portfolio-optimizer", response_model=Dict)
async def portfolio_optimizer(
    request: PortfolioOptimizerRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """Optimize allocations with AI commentary."""
    try:
        result = ai_pipeline.optimize_portfolio(
            [holding.dict() for holding in request.holdings],
            request.risk_profile
        )
        return _with_disclaimer(result)
    except Exception as exc:
        logger.error("Portfolio optimizer error: %s", exc)
        return _error_response("Portfolio optimizer failed")


@router.post("/decision-analyst", response_model=Dict)
async def decision_analyst(
    request: DecisionAssistantRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """Summarize historical decisions for similar contexts."""
    try:
        analysis = ai_pipeline.analyze_company_decision(request.company, request.question)
        return _with_disclaimer(analysis)
    except Exception as exc:
        logger.error("Decision analyst error: %s", exc)
        return _error_response("Decision analysis failed")


@router.post("/prompt", response_model=PromptResponse)
async def process_prompt(
    request: PromptRequest,
    current_user: Dict = Depends(get_current_active_user)
):
    """
    Process a general AI prompt.

    Args:
        request: Prompt request
        current_user: Authenticated user

    Returns:
        AI response
    """
    try:
        response = ai_pipeline.process_prompt(request)
        return _with_disclaimer(response.dict() if hasattr(response, "dict") else dict(response))
    except Exception as e:
        logger.error(f"Error processing prompt: {e}")
        return _error_response("Prompt processing failed")


@router.post("/ai-advice", response_model=Dict)
async def ai_advice(
    request: AdviceRequest,
    current_user: Dict = Depends(get_current_active_user),
):
    """
    Educational-only AI advisory endpoint.

    NOTE:
    This API must never be presented as licensed investment advice.
    See SEBI (Investment Advisers) Regulations, 2013.
    # TODO: Have a qualified lawyer/compliance officer review this wording.
    """
    try:
        resp = ai_pipeline.process_prompt(
            PromptRequest(user_id=str(current_user.get("id", "anon")), question=request.prompt, context=request.context or {})
        )
        payload = resp.dict() if hasattr(resp, "dict") else dict(resp)
        return _with_disclaimer(payload)
    except HTTPException:
        raise
    except Exception as exc:
        logger.error("AI advice error: %s", exc)
        return _error_response("AI advice generation failed")


@router.post("/recommendations", response_model=Dict)
async def recommendations(
    request: RecommendationRequest,
    current_user: Dict = Depends(get_current_active_user),
):
    """
    Generate AI recommendations (educational only; not to be treated as signals).

    NOTE:
    This API must never be presented as licensed investment advice.
    See SEBI (Investment Advisers) Regulations, 2013.
    # TODO: Have a qualified lawyer/compliance officer review this wording.
    """
    try:
        plan = ai_pipeline.generate_trading_plan(request.symbol, request.risk_profile, 10_000)
        payload: Dict[str, Any] = {
            "symbol": request.symbol,
            "risk_profile": request.risk_profile,
            "notes": request.notes,
            "generated_at": __import__("datetime").datetime.now().isoformat(),
            "plan": plan,
        }
        return _with_disclaimer(payload)
    except HTTPException:
        raise
    except Exception as exc:
        logger.error("Recommendation error: %s", exc)
        return _error_response("Recommendation generation failed")

