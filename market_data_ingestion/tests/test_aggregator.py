import asyncio
import pytest
from market_data_ingestion.core.aggregator import TickAggregator


class TestTickAggregator:
    @pytest.mark.asyncio
    async def test_aggregate_tick_creates_new_candle(self):
        """Test that aggregating a tick creates a new candle."""
        aggregator = TickAggregator(flush_interval=60)

        tick = {
            "symbol": "AAPL",
            "ts_utc": "2024-01-01T10:00:00Z",
            "price": 150.0,
            "qty": 100
        }

        await aggregator.aggregate_tick(tick)

        assert "AAPL" in aggregator.candles_1s
        # The bucket key is generated by _get_bucket_key, which returns a string like '2024-01-01 10:00:00+00:00'
        bucket_key = aggregator._get_bucket_key("2024-01-01T10:00:00Z", 1)
        candle = aggregator.candles_1s["AAPL"][bucket_key]
        assert candle["open"] == 150.0
        assert candle["high"] == 150.0
        assert candle["low"] == 150.0
        assert candle["close"] == 150.0
        assert candle["volume"] == 100

    @pytest.mark.asyncio
    async def test_aggregate_tick_updates_existing_candle(self):
        """Test that aggregating multiple ticks updates the same candle."""
        aggregator = TickAggregator(flush_interval=60)

        ticks = [
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:00Z",
                "price": 150.0,
                "qty": 100
            },
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:01Z",
                "price": 151.0,
                "qty": 50
            },
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:02Z",
                "price": 149.0,
                "qty": 75
            }
        ]

        for tick in ticks:
            await aggregator.aggregate_tick(tick)

        # Each tick is in its own 1s bucket since they are at different seconds
        # Check the first candle (10:00:00)
        bucket_key_00 = aggregator._get_bucket_key("2024-01-01T10:00:00Z", 1)
        candle_00 = aggregator.candles_1s["AAPL"][bucket_key_00]
        assert candle_00["open"] == 150.0
        assert candle_00["high"] == 150.0
        assert candle_00["low"] == 150.0
        assert candle_00["close"] == 150.0
        assert candle_00["volume"] == 100

        # Check the second candle (10:00:01)
        bucket_key_01 = aggregator._get_bucket_key("2024-01-01T10:00:01Z", 1)
        candle_01 = aggregator.candles_1s["AAPL"][bucket_key_01]
        assert candle_01["open"] == 151.0
        assert candle_01["high"] == 151.0
        assert candle_01["low"] == 151.0
        assert candle_01["close"] == 151.0
        assert candle_01["volume"] == 50

        # Check the third candle (10:00:02)
        bucket_key_02 = aggregator._get_bucket_key("2024-01-01T10:00:02Z", 1)
        candle_02 = aggregator.candles_1s["AAPL"][bucket_key_02]
        assert candle_02["open"] == 149.0
        assert candle_02["high"] == 149.0
        assert candle_02["low"] == 149.0
        assert candle_02["close"] == 149.0
        assert candle_02["volume"] == 75

    @pytest.mark.asyncio
    async def test_aggregate_tick_handles_multiple_symbols(self):
        """Test that aggregator handles multiple symbols correctly."""
        aggregator = TickAggregator(flush_interval=60)

        ticks = [
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:00Z",
                "price": 150.0,
                "qty": 100
            },
            {
                "symbol": "GOOGL",
                "ts_utc": "2024-01-01T10:00:00Z",
                "price": 2800.0,
                "qty": 10
            }
        ]

        for tick in ticks:
            await aggregator.aggregate_tick(tick)

        assert "AAPL" in aggregator.candles_1s
        assert "GOOGL" in aggregator.candles_1s

        bucket_key = aggregator._get_bucket_key("2024-01-01T10:00:00Z", 1)
        aapl_candle = aggregator.candles_1s["AAPL"][bucket_key]
        assert aapl_candle["open"] == 150.0

        googl_candle = aggregator.candles_1s["GOOGL"][bucket_key]
        assert googl_candle["open"] == 2800.0

    @pytest.mark.asyncio
    async def test_aggregate_tick_handles_1m_candles(self):
        """Test that 1m candles are aggregated correctly."""
        aggregator = TickAggregator(flush_interval=60)

        ticks = [
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:00Z",
                "price": 150.0,
                "qty": 100
            },
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:00:30Z",
                "price": 151.0,
                "qty": 50
            },
            {
                "symbol": "AAPL",
                "ts_utc": "2024-01-01T10:01:00Z",
                "price": 152.0,
                "qty": 75
            }
        ]

        for tick in ticks:
            await aggregator.aggregate_tick(tick)

        # Check 1s candles
        assert len(aggregator.candles_1s["AAPL"]) == 3

        # Check 1m candles - should have 2 buckets (10:00 and 10:01)
        assert len(aggregator.candles_1m["AAPL"]) == 2

        # First minute candle - bucket key for 60s interval
        bucket_key_10_00 = aggregator._get_bucket_key("2024-01-01T10:00:00Z", 60)
        candle_10_00 = aggregator.candles_1m["AAPL"][bucket_key_10_00]
        assert candle_10_00["open"] == 150.0
        assert candle_10_00["high"] == 151.0
        assert candle_10_00["low"] == 150.0
        assert candle_10_00["close"] == 151.0
        assert candle_10_00["volume"] == 150

        # Second minute candle
        bucket_key_10_01 = aggregator._get_bucket_key("2024-01-01T10:01:00Z", 60)
        candle_10_01 = aggregator.candles_1m["AAPL"][bucket_key_10_01]
        assert candle_10_01["open"] == 152.0
        assert candle_10_01["high"] == 152.0
        assert candle_10_01["low"] == 152.0
        assert candle_10_01["close"] == 152.0
        assert candle_10_01["volume"] == 75
