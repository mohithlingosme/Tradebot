"""
Strategy Interface for Backtesting

Defines the contract for trading strategies in the backtesting system.
Provides indicator library and state management.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from decimal import Decimal
from enum import Enum

from common.market_data import Candle
from .fill_simulator import OrderSide, OrderType, BacktestOrder


class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    quantity: Optional[int] = None
    price: Optional[Decimal] = None
    order_type: OrderType = OrderType.MARKET
    stop_price: Optional[Decimal] = None
    timestamp: datetime = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


@dataclass
class StrategyState:
    """Persistent state for a strategy."""
    symbol: str
    position: int = 0
    entry_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    custom_data: Dict[str, Any] = field(default_factory=dict)
    last_signal: Optional[Signal] = None
    entry_time: Optional[datetime] = None


class IndicatorLibrary:
    """
    Library of technical indicators for strategy development.

    Provides common indicators: SMA, EMA, RSI, MACD, ATR, VWAP, etc.
    """

    @staticmethod
    def sma(prices: List[Decimal], period: int) -> Optional[Decimal]:
        """Simple Moving Average."""
        if len(prices) < period:
            return None
        return sum(prices[-period:]) / period

    @staticmethod
    def ema(prices: List[Decimal], period: int) -> Optional[Decimal]:
        """Exponential Moving Average."""
        if len(prices) < period:
            return None

        if len(prices) == period:
            return sum(prices) / period

        # Calculate EMA
        multiplier = 2 / (period + 1)
        ema_value = sum(prices[:period]) / period

        for price in prices[period:]:
            ema_value = (price * multiplier) + (ema_value * (1 - multiplier))

        return ema_value

    @staticmethod
    def rsi(prices: List[Decimal], period: int = 14) -> Optional[Decimal]:
        """Relative Strength Index."""
        if len(prices) < period + 1:
            return None

        gains = []
        losses = []

        for i in range(1, len(prices)):
            change = prices[i] - prices[i-1]
            if change > 0:
                gains.append(change)
                losses.append(Decimal('0'))
            else:
                gains.append(Decimal('0'))
                losses.append(abs(change))

        if len(gains) < period or len(losses) < period:
            return None

        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period

        if avg_loss == 0:
            return Decimal('100')

        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def macd(prices: List[Decimal], fast_period: int = 12, slow_period: int = 26,
             signal_period: int = 9) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """MACD (Moving Average Convergence Divergence)."""
        fast_ema = IndicatorLibrary.ema(prices, fast_period)
        slow_ema = IndicatorLibrary.ema(prices, slow_period)

        if fast_ema is None or slow_ema is None:
            return None, None, None

        macd_line = fast_ema - slow_ema

        # Signal line (EMA of MACD)
        macd_values = []
        for i in range(slow_period, len(prices)):
            subset = prices[:i+1]
            fast = IndicatorLibrary.ema(subset, fast_period)
            slow = IndicatorLibrary.ema(subset, slow_period)
            if fast is not None and slow is not None:
                macd_values.append(fast - slow)

        signal_line = IndicatorLibrary.ema(macd_values, signal_period) if len(macd_values) >= signal_period else None

        # Histogram
        histogram = macd_line - signal_line if signal_line is not None else None

        return macd_line, signal_line, histogram

    @staticmethod
    def atr(highs: List[Decimal], lows: List[Decimal], closes: List[Decimal], period: int = 14) -> Optional[Decimal]:
        """Average True Range."""
        if len(highs) < period or len(lows) < period or len(closes) < period:
            return None

        true_ranges = []

        for i in range(1, len(highs)):
            tr1 = highs[i] - lows[i]
            tr2 = abs(highs[i] - closes[i-1])
            tr3 = abs(lows[i] - closes[i-1])
            true_ranges.append(max(tr1, tr2, tr3))

        if len(true_ranges) < period:
            return None

        return sum(true_ranges[-period:]) / period

    @staticmethod
    def bollinger_bands(prices: List[Decimal], period: int = 20, std_dev: float = 2.0) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """Bollinger Bands."""
        if len(prices) < period:
            return None, None, None

        sma = IndicatorLibrary.sma(prices, period)
        if sma is None:
            return None, None, None

        # Calculate standard deviation
        squared_diffs = [(price - sma) ** 2 for price in prices[-period:]]
        variance = sum(squared_diffs) / period
        std = variance ** 0.5

        upper_band = sma + (Decimal(str(std)) * Decimal(str(std_dev)))
        lower_band = sma - (Decimal(str(std)) * Decimal(str(std_dev)))

        return sma, upper_band, lower_band

    @staticmethod
    def vwap(highs: List[Decimal], lows: List[Decimal], closes: List[Decimal],
             volumes: List[int]) -> Optional[Decimal]:
        """Volume Weighted Average Price."""
        if len(highs) != len(lows) != len(closes) != len(volumes):
            return None

        if not volumes:
            return None

        total_volume = sum(volumes)
        if total_volume == 0:
            return None

        # Use typical price (H+L+C)/3
        typical_prices = [(h + l + c) / 3 for h, l, c in zip(highs, lows, closes)]
        vwap = sum(tp * vol for tp, vol in zip(typical_prices, volumes)) / total_volume

        return vwap

    @staticmethod
    def stochastic_oscillator(highs: List[Decimal], lows: List[Decimal], closes: List[Decimal],
                            k_period: int = 14, d_period: int = 3) -> Tuple[Optional[Decimal], Optional[Decimal]]:
        """Stochastic Oscillator."""
        if len(highs) < k_period or len(lows) < k_period or len(closes) < k_period:
            return None, None

        # Calculate %K
        recent_highs = highs[-k_period:]
        recent_lows = lows[-k_period:]
        current_close = closes[-1]

        highest_high = max(recent_highs)
        lowest_low = min(recent_lows)

        if highest_high == lowest_low:
            k_value = Decimal('50')  # Neutral when no range
        else:
            k_value = ((current_close - lowest_low) / (highest_high - lowest_low)) * 100

        # Calculate %D (SMA of %K)
        if len(closes) >= k_period + d_period - 1:
            k_values = []
            for i in range(d_period):
                start_idx = -(k_period + d_period - 1 - i)
                end_idx = -(d_period - 1 - i) if i < d_period - 1 else None

                period_highs = highs[start_idx:end_idx]
                period_lows = lows[start_idx:end_idx]
                period_close = closes[end_idx - 1 if end_idx else -1]

                if period_highs and period_lows:
                    ph = max(period_highs)
                    pl = min(period_lows)
                    if ph != pl:
                        k_val = ((period_close - pl) / (ph - pl)) * 100
                        k_values.append(k_val)

            d_value = sum(k_values[-d_period:]) / d_period if len(k_values) >= d_period else None
        else:
            d_value = None

        return k_value, d_value


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Strategies must implement the generate_signals method.
    """

    def __init__(self, name: str, symbols: List[str], parameters: Dict[str, Any] = None):
        self.name = name
        self.symbols = symbols
        self.parameters = parameters or {}

        # State management
        self.states: Dict[str, StrategyState] = {}
        for symbol in symbols:
            self.states[symbol] = StrategyState(symbol=symbol)

        # Indicator cache for performance
        self.indicator_cache: Dict[str, Dict[str, Any]] = {}

    @abstractmethod
    def generate_signals(self, symbol: str, candles: List[Candle],
                        current_position: int) -> List[Signal]:
        """
        Generate trading signals for a symbol.

        Args:
            symbol: Trading symbol
            candles: Historical candles (most recent last)
            current_position: Current position quantity

        Returns:
            List of signals to execute
        """
        pass

    def update_state(self, symbol: str, signal: Signal, fill_price: Optional[Decimal] = None) -> None:
        """Update strategy state after signal execution."""
        state = self.states[symbol]

        if signal.signal_type in [SignalType.BUY, SignalType.SELL]:
            # Update position
            quantity = signal.quantity or 0
            if signal.signal_type == SignalType.BUY:
                if state.position <= 0:  # Opening or reversing to long
                    state.entry_price = fill_price or signal.price
                    state.entry_time = signal.timestamp
                state.position += quantity
            else:  # SELL
                if state.position >= 0:  # Opening or reversing to short
                    state.entry_price = fill_price or signal.price
                    state.entry_time = signal.timestamp
                state.position -= quantity

            # Update stop loss and take profit if provided
            if signal.stop_price:
                state.stop_loss = signal.stop_price

        elif signal.signal_type == SignalType.CLOSE:
            # Close position
            state.position = 0
            state.entry_price = None
            state.stop_loss = None
            state.take_profit = None
            state.entry_time = None

        state.last_signal = signal

    def get_state(self, symbol: str) -> StrategyState:
        """Get current state for a symbol."""
        return self.states[symbol]

    def calculate_indicators(self, symbol: str, candles: List[Candle]) -> Dict[str, Any]:
        """Calculate and cache indicators for a symbol."""
        if symbol not in self.indicator_cache:
            self.indicator_cache[symbol] = {}

        cache = self.indicator_cache[symbol]

        # Extract price data
        closes = [Decimal(str(c.close)) for c in candles]
        highs = [Decimal(str(c.high)) for c in candles]
        lows = [Decimal(str(c.low)) for c in candles]
        volumes = [c.volume for c in candles]

        # Calculate common indicators
        cache['sma_20'] = IndicatorLibrary.sma(closes, 20)
        cache['sma_50'] = IndicatorLibrary.sma(closes, 50)
        cache['ema_12'] = IndicatorLibrary.ema(closes, 12)
        cache['ema_26'] = IndicatorLibrary.ema(closes, 26)
        cache['rsi_14'] = IndicatorLibrary.rsi(closes, 14)
        cache['macd'], cache['macd_signal'], cache['macd_hist'] = IndicatorLibrary.macd(closes)
        cache['atr_14'] = IndicatorLibrary.atr(highs, lows, closes, 14)
        cache['bb_middle'], cache['bb_upper'], cache['bb_lower'] = IndicatorLibrary.bollinger_bands(closes)
        cache['vwap'] = IndicatorLibrary.vwap(highs, lows, closes, volumes)
        cache['stoch_k'], cache['stoch_d'] = IndicatorLibrary.stochastic_oscillator(highs, lows, closes)

        return cache

    def get_indicator(self, symbol: str, indicator_name: str, candles: List[Candle]) -> Any:
        """Get a specific indicator value, calculating if necessary."""
        cache = self.calculate_indicators(symbol, candles)
        return cache.get(indicator_name)


class ExampleStrategy(BaseStrategy):
    """Example strategy implementation - Simple moving average crossover."""

    def generate_signals(self, symbol: str, candles: List[Candle],
                        current_position: int) -> List[Signal]:
        signals = []

        if len(candles) < 50:
            return signals

        # Get indicators
        indicators = self.calculate_indicators(symbol, candles)
        sma_20 = indicators.get('sma_20')
        sma_50 = indicators.get('sma_50')

        if sma_20 is None or sma_50 is None:
            return signals

        current_price = Decimal(str(candles[-1].close))
        state = self.get_state(symbol)

        # Generate signals based on SMA crossover
        if sma_20 > sma_50 and (state.position <= 0):
            # Bullish crossover - go long
            signals.append(Signal(
                symbol=symbol,
                signal_type=SignalType.BUY,
                quantity=100,  # Fixed quantity for example
                order_type=OrderType.MARKET,
                timestamp=candles[-1].timestamp
            ))

        elif sma_20 < sma_50 and (state.position >= 0):
            # Bearish crossover - go short or close
            if state.position > 0:
                signals.append(Signal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE,
                    order_type=OrderType.MARKET,
                    timestamp=candles[-1].timestamp
                ))
            else:
                signals.append(Signal(
                    symbol=symbol,
                    signal_type=SignalType.SELL,
                    quantity=100,
                    order_type=OrderType.MARKET,
                    timestamp=candles[-1].timestamp
                ))

        return signals


# Strategy registry for dynamic loading
STRATEGY_REGISTRY = {
    'example_sma_crossover': ExampleStrategy,
}


def create_strategy(strategy_name: str, symbols: List[str], parameters: Dict[str, Any] = None) -> BaseStrategy:
    """Factory function to create strategies by name."""
    strategy_class = STRATEGY_REGISTRY.get(strategy_name)
    if strategy_class is None:
        raise ValueError(f"Unknown strategy: {strategy_name}")

    return strategy_class(strategy_name, symbols, parameters)


# Example usage
if __name__ == "__main__":
    from datetime import datetime, timezone

    # Create sample candles
    candles = []
    base_time = datetime(2024, 1, 1, 9, 30, tzinfo=timezone.utc)

    for i in range(100):
        candles.append(Candle(
            symbol="RELIANCE",
            timestamp=base_time,
            open=2500 + i,
            high=2520 + i,
            low=2490 + i,
            close=2510 + i,
            volume=10000 + i * 100,
            timeframe="1m"
        ))
        base_time = base_time.replace(minute=base_time.minute + 1)

    # Create and test strategy
    strategy = ExampleStrategy("test_strategy", ["RELIANCE"])

    signals = strategy.generate_signals("RELIANCE", candles, 0)

    print(f"Generated {len(signals)} signals")
    for signal in signals:
        print(f"Signal: {signal.signal_type} {signal.quantity} {signal.symbol}")

    # Test indicators
    indicators = strategy.calculate_indicators("RELIANCE", candles)
    print(f"SMA 20: {indicators.get('sma_20')}")
    print(f"RSI 14: {indicators.get('rsi_14')}")
    print(f"MACD: {indicators.get('macd')}")
